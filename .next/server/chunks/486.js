"use strict";exports.id=486,exports.ids=[486],exports.modules={65635:(e,t,a)=>{a.r(t),a.d(t,{FirestoreRepository:()=>s});var r=a(76),n=a(90445);class s{getDb(){let{db:e}=(0,n.getFirebase)();if(!e)throw Error("Firebase not initialized. Please check your Firebase configuration.");return e}async getTranslation(e){let t=this.getDb(),a=(0,r.JU)(t,"translations",e),n=await (0,r.QT)(a);if(!n.exists())return null;let s=n.data();return{...s,createdAt:s.createdAt?.toDate(),updatedAt:s.updatedAt?.toDate()}}async saveTranslation(e){let t=this.getDb(),a=(0,r.JU)(t,"translations",e.id),n=r.EK.now(),s={...e,createdAt:e.createdAt?r.EK.fromDate(e.createdAt):n,updatedAt:n};await (0,r.pl)(a,s,{merge:!0})}async getAllTranslations(){let e=this.getDb(),t=(0,r.IO)((0,r.hJ)(e,"translations"));return(await (0,r.PL)(t)).docs.map(e=>{let t=e.data();return{...t,createdAt:t.createdAt?.toDate(),updatedAt:t.updatedAt?.toDate()}})}subscribeToTranslation(e,t){let a=this.getDb(),n=(0,r.JU)(a,"translations",e);return(0,r.cf)(n,e=>{if(!e.exists()){t(null);return}let a=e.data();t({...a,createdAt:a.createdAt?.toDate(),updatedAt:a.updatedAt?.toDate()})})}subscribeToAllTranslations(e){let t=this.getDb(),a=(0,r.IO)((0,r.hJ)(t,"translations"));return(0,r.cf)(a,t=>{e(t.docs.map(e=>{let t=e.data();return{...t,createdAt:t.createdAt?.toDate(),updatedAt:t.updatedAt?.toDate()}}))})}async getProjectionChannel(e){let t=this.getDb(),a=(0,r.JU)(t,"channels",e),n=await (0,r.QT)(a);if(!n.exists())return null;let s=n.data();return{...s,timestamp:s.timestamp?.toDate()}}async saveProjectionChannel(e,t){let a=this.getDb(),n=(0,r.JU)(a,"channels",e),s={...t,timestamp:t.timestamp?r.EK.fromDate(t.timestamp):r.EK.now()};await (0,r.pl)(n,s,{merge:!0})}subscribeToProjectionChannel(e,t){let a=this.getDb(),n=(0,r.JU)(a,"channels",e);return(0,r.cf)(n,e=>{if(!e.exists()){t(null);return}let a=e.data();t({...a,timestamp:a.timestamp?.toDate()})})}}},7486:(e,t,a)=>{a.d(t,{R:()=>w});var r=a(60114),n=a(84679);let s=null;function i(){return s||(s=(0,n.X3)("rpv-bible-cache",1,{upgrade(e){e.objectStoreNames.contains("translations")||e.createObjectStore("translations",{keyPath:"id"}).createIndex("by-id","id",{unique:!0}),e.objectStoreNames.contains("projectionChannels")||e.createObjectStore("projectionChannels",{keyPath:"channelId"}).createIndex("by-channel","channelId",{unique:!0})}})),s}class o{async saveTranslation(e){try{let t=await i();await t.put("translations",e)}catch(e){console.error("Error saving translation to IndexedDB:",e)}}async getTranslation(e){try{let t=await i();return await t.get("translations",e)||null}catch(e){return console.error("Error getting translation from IndexedDB:",e),null}}async getAllTranslations(){try{let e=await i();return await e.getAll("translations")}catch(e){return console.error("Error getting all translations from IndexedDB:",e),[]}}async deleteTranslation(e){try{let t=await i();await t.delete("translations",e)}catch(e){console.error("Error deleting translation from IndexedDB:",e)}}async saveProjectionChannel(e,t){try{let a=await i();await a.put("projectionChannels",{channelId:e,ref:t,timestamp:Date.now()})}catch(e){console.error("Error saving projection channel to IndexedDB:",e)}}async getProjectionChannel(e){try{let t=await i(),a=await t.get("projectionChannels",e);return a?.ref||null}catch(e){return console.error("Error getting projection channel from IndexedDB:",e),null}}async clearCache(){try{let e=await i();await e.clear("translations"),await e.clear("projectionChannels")}catch(e){console.error("Error clearing IndexedDB cache:",e)}}async isAvailable(){try{return await i(),!0}catch{return!1}}}var l=a(65635);class c{async getPendingOperations(){return[]}async addOperation(e){}async removeOperation(e){}async incrementRetry(e){}async clearQueue(){}async processQueue(e){for(let t of(await this.getPendingOperations()))try{let a=e[t.type];if(!a){await this.removeOperation(t.id);continue}await a(t.data),await this.removeOperation(t.id)}catch(e){console.error(`Error processing ${t.type}:`,e),await this.incrementRetry(t.id)}}}var h=a(86689);class d{constructor(){this.memoryCache=new Map,this.indexedDB=new o,this.repository=new l.FirestoreRepository,this.offlineQueue=new c,h.I.subscribe(async e=>{e&&await this.processPendingOperations()})}async getTranslation(e){if(this.memoryCache.has(e))return this.memoryCache.get(e);try{let t=await this.indexedDB.getTranslation(e);if(t)return this.memoryCache.set(e,t),t}catch(e){console.warn("IndexedDB cache read failed, trying Firestore:",e)}try{let{db:t}=await Promise.resolve().then(a.bind(a,90445)).then(e=>e.getFirebase());if(t){let t=await this.repository.getTranslation(e);return t&&(this.memoryCache.set(e,t),await this.indexedDB.saveTranslation(t).catch(()=>{})),t}}catch(e){console.warn("Firestore read failed:",e)}return null}async getAllTranslations(){try{let e=await this.indexedDB.getAllTranslations();if(e.length>0)return e.forEach(e=>this.memoryCache.set(e.id,e)),this.refreshFromFirestore().catch(()=>{}),e}catch(e){console.warn("IndexedDB read failed, trying Firestore:",e)}try{let{db:e}=await Promise.resolve().then(a.bind(a,90445)).then(e=>e.getFirebase());if(e){let e=await this.repository.getAllTranslations();return e.forEach(e=>{this.memoryCache.set(e.id,e),this.indexedDB.saveTranslation(e).catch(()=>{})}),e}}catch(e){console.warn("Firestore read failed:",e)}return[]}async saveTranslation(e){this.memoryCache.set(e.id,e),await this.indexedDB.saveTranslation(e).catch(()=>{});let t=h.I.getOnline();try{let{db:r,auth:n}=await Promise.resolve().then(a.bind(a,90445)).then(e=>e.getFirebase()),s=!!n&&!!n.currentUser;r&&t&&s?await this.repository.saveTranslation(e):t||await this.offlineQueue.addOperation({type:"saveTranslation",data:e})}catch(a){let t=String(a?.toString?.()||a);t.includes("Missing or insufficient permissions")||t.includes("permission-denied")||await this.offlineQueue.addOperation({type:"saveTranslation",data:e})}}async mergeTranslation(e){let t;let r=await this.getTranslation(e.id);t=r?this.mergeTranslations(r,e):e,this.memoryCache.set(t.id,t),await this.indexedDB.saveTranslation(t).catch(()=>{});let n=h.I.getOnline();try{let{db:e,auth:r}=await Promise.resolve().then(a.bind(a,90445)).then(e=>e.getFirebase()),s=!!r&&!!r.currentUser;e&&n&&s?await this.repository.saveTranslation(t):n||await this.offlineQueue.addOperation({type:"mergeTranslation",data:t})}catch(a){let e=String(a?.toString?.()||a);e.includes("Missing or insufficient permissions")||e.includes("permission-denied")||await this.offlineQueue.addOperation({type:"mergeTranslation",data:t})}return t}async getProjectionChannel(e){try{let t=await this.indexedDB.getProjectionChannel(e);if(t)return t}catch(e){console.warn("IndexedDB read failed:",e)}try{let{db:t}=await Promise.resolve().then(a.bind(a,90445)).then(e=>e.getFirebase());if(t){let t=await this.repository.getProjectionChannel(e);return t&&await this.indexedDB.saveProjectionChannel(e,t).catch(()=>{}),t}}catch(e){console.warn("Firestore read failed:",e)}return null}async saveProjectionChannel(e,t){await this.indexedDB.saveProjectionChannel(e,t).catch(()=>{});let r=h.I.getOnline();try{let{db:n}=await Promise.resolve().then(a.bind(a,90445)).then(e=>e.getFirebase());n&&r?await this.repository.saveProjectionChannel(e,t):r||await this.offlineQueue.addOperation({type:"sendToProjector",data:{channelId:e,ref:t}})}catch(a){console.warn("Firestore save failed, queuing for later:",a),await this.offlineQueue.addOperation({type:"sendToProjector",data:{channelId:e,ref:t}})}}async refreshFromFirestore(){try{let{db:e}=await Promise.resolve().then(a.bind(a,90445)).then(e=>e.getFirebase());if(!e)return;(await this.repository.getAllTranslations()).forEach(e=>{this.memoryCache.set(e.id,e),this.indexedDB.saveTranslation(e).catch(()=>{})})}catch(e){}}mergeTranslations(e,t){let a;let r=e.books.find(e=>e.name===t.books[0]?.name);if(r){let n=t.books[0],s=[...r.chapters];n.chapters.forEach(e=>{let t=s.findIndex(t=>t.number===e.number);if(t>=0){let a=s[t],r=[...a.verses];e.verses.forEach(e=>{let t=r.findIndex(t=>t.number===e.number);t>=0?r[t]=e:r.push(e)}),r.sort((e,t)=>e.number-t.number),s[t]={...a,verses:r}}else s.push(e)}),s.sort((e,t)=>e.number-t.number),a=e.books.map(e=>e.name===r.name?{...e,chapters:s}:e)}else a=[...e.books,t.books[0]];return{...e,name:t.name||e.name,books:a,updatedAt:new Date}}clearMemoryCache(){this.memoryCache.clear()}async clearAllCaches(){this.memoryCache.clear(),await this.indexedDB.clearCache(),await this.offlineQueue.clearQueue()}async processPendingOperations(){try{let{auth:e}=await Promise.resolve().then(a.bind(a,90445)).then(e=>e.getFirebase());if(!(e&&e.currentUser))return}catch{return}await this.offlineQueue.processQueue({saveTranslation:async e=>{let{db:t}=await Promise.resolve().then(a.bind(a,90445)).then(e=>e.getFirebase());t&&await this.repository.saveTranslation(e)},mergeTranslation:async e=>{await this.mergeTranslation(e)},sendToProjector:async e=>{let{db:t}=await Promise.resolve().then(a.bind(a,90445)).then(e=>e.getFirebase());t&&await this.repository.saveProjectionChannel(e.channelId,e.ref)}})}}class u{constructor(){this.cacheManager=new d}async getTranslation(e){try{return await this.cacheManager.getTranslation(e)}catch(e){throw console.error("Error getting translation:",e),e}}async getAllTranslations(){try{return await this.cacheManager.getAllTranslations()}catch(e){throw console.error("Error getting all translations:",e),e}}async saveTranslation(e){try{let t=new Date,a={...e,createdAt:e.createdAt||t,updatedAt:t};await this.cacheManager.saveTranslation(a)}catch(e){throw console.error("Error saving translation:",e),e}}async mergeTranslation(e){try{return await this.cacheManager.mergeTranslation(e)}catch(e){throw console.error("Error merging translation:",e),e}}async addOrUpdateVerse(e,t,a,r,n){try{let s=await this.getTranslation(e);if(!s){await this.saveTranslation({id:e,name:e,books:[{name:t,chapters:[{number:a,verses:[{number:r,text:n}]}]}]});return}let i=this.addVerseToTranslation(s,t,a,r,n);await this.saveTranslation(i)}catch(e){throw console.error("Error adding/updating verse:",e),e}}addVerseToTranslation(e,t,a,r,n){let s=e.books.find(e=>e.name===t);if(s){let e=s.chapters.find(e=>e.number===a);if(e){let t=e.verses.find(e=>e.number===r);t?t.text=n:(e.verses.push({number:r,text:n}),e.verses.sort((e,t)=>e.number-t.number))}else s.chapters.push({number:a,verses:[{number:r,text:n}]}),s.chapters.sort((e,t)=>e.number-t.number)}else e.books.push({name:t,chapters:[{number:a,verses:[{number:r,text:n}]}]});return{...e,updatedAt:new Date}}subscribeToTranslation(e,t){let{FirestoreRepository:r}=a(65635);return new r().subscribeToTranslation(e,t)}subscribeToAllTranslations(e){let{FirestoreRepository:t}=a(65635);return new t().subscribeToAllTranslations(e)}}class m{constructor(){this.cacheManager=new d}async sendToProjector(e,t){try{let{current:a}=w.getState();if(!a)return;let r=a.books.find(e=>e.name===t.book),n=r?.chapters.find(e=>e.number===t.chapter),s=n?.verses.find(e=>e.number===t.verse),i={translation:a.name,book:t.book,chapter:t.chapter,verse:t.verse,text:s?.text||"",timestamp:new Date};await this.cacheManager.saveProjectionChannel(e,i)}catch(e){throw console.error("Error sending to projector:",e),e}}subscribeToChannel(e,t){let{FirestoreRepository:r}=a(65635);return new r().subscribeToProjectionChannel(e,a=>{a&&this.cacheManager.saveProjectionChannel(e,a).catch(()=>{}),t(a)})}async getChannel(e){try{return await this.cacheManager.getProjectionChannel(e)}catch(e){throw console.error("Error getting channel:",e),e}}}let g={id:"sample",name:"Sample Translation",books:[{name:"John",chapters:[{number:3,verses:[{number:16,text:"For God so loved the world, that he gave his only Son, that whoever believes in him should not perish but have eternal life."}]}]}]},w=(0,r.Ue)((e,t)=>{let r=new u,n=new m;return{translations:[],current:null,projectorRef:{translation:"",book:"",chapter:0,verse:0,text:""},channelId:"default",isLoading:!1,error:null,_translationService:r,_projectionService:n,_unsubscribers:{},loadTranslations:async()=>{e({isLoading:!0,error:null});try{let n=await r.getAllTranslations();if(0===n.length){try{let t=[];for(let e of[{url:"/translations/kjv.json"},{url:"/translations/asv.json"}])try{let a=await fetch(e.url,{cache:"no-store"});if(a.ok){let e=await a.json(),n=e?.translations??[];if(Array.isArray(n)&&n.length>0)for(let e of n)await r.saveTranslation(e),t.push(e)}}catch{}if(t.length>0){e({translations:t,current:t[0],isLoading:!1});return}}catch{}t().loadSample(),e({isLoading:!1});return}try{let t=new Set(n.map(e=>e.id)),a=["kjv","asv"].filter(e=>!t.has(e)),s=[];if(a.length>0)for(let e of a){let t=await fetch(`/translations/${e}.json`,{cache:"no-store"});if(t.ok){let e=await t.json();for(let t of e?.translations??[])await r.saveTranslation(t),s.push(t)}}let i=s.length>0?[...n,...s]:n;e({translations:i,current:i[0]??null,isLoading:!1})}catch{e({translations:n,current:n[0]??null,isLoading:!1})}try{let{db:n}=await Promise.resolve().then(a.bind(a,90445)).then(e=>e.getFirebase());if(n){let a=r.subscribeToAllTranslations(a=>{e({translations:a,current:t().current??a[0]??null})}),n=t()._unsubscribers;n.translations&&n.translations(),n.translations=a}}catch(e){console.warn("Firestore subscription failed, using cached data:",e)}}catch(a){console.error("Error loading translations:",a),e({error:a instanceof Error?a.message:"Failed to load translations",isLoading:!1}),t().loadSample()}},loadSample:()=>{0===t().translations.length&&e({translations:[g],current:g})},setCurrent:a=>{e({current:t().translations.find(e=>e.id===a)??null})},setReference:e=>{},setChannelId:a=>{e({channelId:a}),t().subscribeToChannel()},sendToProjector:async e=>{try{let{current:a,channelId:r}=t();if(!a)return;await n.sendToProjector(r||"default",e)}catch(r){console.error("Error sending to projector:",r);let{current:e,channelId:a}=t()}},subscribeToChannel:()=>{let{channelId:r,_projectionService:n}=t(),s=t()._unsubscribers;s.channel&&s.channel();let{getFirebase:i}=a(90445),{db:o}=i();if(o)try{let t=n.subscribeToChannel(r||"default",t=>{t&&e({projectorRef:t})});s.channel=t;return}catch(e){console.error("Error subscribing to Firestore channel:",e)}},importJson:async a=>{try{let r=a.translations??[],{_translationService:n}=t();for(let e of r)await n.saveTranslation(e);e({translations:r,current:r[0]??null})}catch(r){console.error("Error importing JSON:",r);let t=a.translations??[];e({translations:t,current:t[0]??null})}},mergeTranslation:async a=>{try{let{_translationService:r}=t(),n=await r.mergeTranslation(a),s=t(),i=s.translations.findIndex(e=>e.id===a.id);if(i>=0){let t=[...s.translations];t[i]=n,e({translations:t,current:s.current?.id===a.id?n:s.current})}else e({translations:[...s.translations,n],current:s.current??n})}catch(e){throw console.error("Error merging translation:",e),e}},addOrUpdateVerse:async({translationId:e,book:a,chapter:r,verse:n,text:s})=>{try{let{_translationService:i}=t();await i.addOrUpdateVerse(e,a,r,n,s),await t().loadTranslations()}catch(e){throw console.error("Error adding/updating verse:",e),e}}}})}};